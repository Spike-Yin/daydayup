# 假装从零开始的Python学习体验

一些对编程的基本概念和领悟理解

* 程序只会有三个流程, 顺序, 分支, 循环
* 顺序就是从上到下, 依次执行代码
* 分支 , 就是有条件判断, if吗.          ez的
* 循环     就是特定代码重复执行咯
* 啊对,  所谓的参数,  也就是把外面的数字传到里面,让里面运算
* 形参和实参就是有没有具体数字
* 返回值:   一个函数执行后, 返回执行后的结果,    函数执行结束后,  返回给调用者的一个结果
* return还有一个结尾的作用,  return后  后面的代码就不会执行了
* ==py中所有的非数字型的变量都是一个序列,   也可以理解为  容器==
* 方法   最重要的用法还是需要变量名在前面, 变量名加方法   ==[这个变量名也叫对象]==
* 所以方法本身是面向对象的产物, 而函数大抵是过程性编程的产物,  因为函数永远是自己写出来的
* 遍历就是从列表中从头到尾依次取出每一个元素(说的就是for)
* ==迭代就是重复的意思==
* 虽然列表可以存储不同类型的数据, 但在绝大多数开发中,列表里往往都是相同类型的数据
* 元组被用于存储不同类型的数据, 只不过不能修改, 这能适用于特定场景
* break本身具有退出循环之意, 所以搁哪儿好像都行
* import os  其实是调用操作系统接口
* 布尔判断是个非常好的思路,   用于次数限制,  在指定次数前都是false

## 程序和变量

* 程序就是一个处理数据的玩意儿

* 变量啥啊, 函数啥啊  这些的名字有时又被叫做标识符

* 变量就是储存数据的玩意儿,   ==每一个变量的设置,都需要先赋值==

  ```python
  变量名 = 值    // 变量定义
  ```

* 每一个程序执行完,就是那种,  变量所占据的空间没用了吧, 那就一起释放掉, 内存空间小, 每一处空间都很宝贵,一个==独立==程序执行完毕, 这个==独立==程序里的变量空间都会释放掉

```python
// 下面就是python程序和变量涉及的语法了
// 说回来, 雀食哦, 有了那种思维模式习惯后, 我就感觉代码语法没啥重要的了
// 重点还是设计, 还是逻辑
// 这个代码该怎么设计, 该怎么办才能效率最高, 才能解耦, 才能吃内存最小
// 最关键的当然是, 勾八代码到底怎么才能成功运行
# 买卖商品
price = 8.5
weight = 7.5
money = price * weight
print(money)

type(price)   // 查看变量类型
// 雀食简单啊, 雀食简单啊, 雀食啊雀食
```

==pycharm小技巧捏==

* 就是断点, 调试功能, ez的很, 在哪行有问题的代码前面加个断点, 然后按调试, 之后调试版上就有运行该代码出现的问题了

==变量类型捏==

* 这几把还需要学吗?  整型 int, 浮点数 float, 长整型 long, 字符串 str,    布尔类型(==bool==   true or false) 
* 列表(list) ,  元组,  字典

```
//字符串连接 
first_name = "san"
last_name="zhang"
full_name =first_name+last_name
print(full_name)
// out: san zhang 
first_name*10
// out: sansansansansansansnasnasnasna....

first_name+"10"
// san10
# 雀食 EZ 捏
-------------------------------------------------------------
//变量的输入
input函数
input("请输入银行密码")
然后输入密码
// input输入的都是字符串
-------------------------------------------------------------
password=input("请输入密码")
// 给了个变量让输入的东西赋值, 就是给个存储空间呗
---------------------------------------------------------------
类型转换函数,   将input输入的字符串换成别的类型
float(x)
int(x)      int("123")
```

```
// 超高级の商品买卖
price_str=input("请输入价格")
weight_str=input("请输入重量")   //input函数
price=float(price_str)            //类型转换
weight=float(weight_str)
money=price*wight
print(money)
```

```
// 又升级啦
price=float(input("请输入价格"))
weight=float(input("请输入重量"))
```

* 变量的格式化输出
* 格式化输出说白了就是不仅输出了文字, 也把数据也包含在里面
* 那这些数据和文字的类型用不通用,  通过简单的变量相加, 代码不是又臭又长吗
* 诶, 这就要说道格式化输出了
* 格式化输出牛逼plus

```
//  变量的格式化输出
%s    字符串
%d    有符号的十进制整数
%f    浮点数
%%    输出%
print("格式化字符串"%变量1)
print("格式化字符串"%(变量1, 变量2....))
-------------------------------------------------------------------
比如:
name="xx"
print("我的名字是 %s" % name)

student_nu=2
print("我的名字是 %06d" % student_nu)
输出: 000002      //6的意思是, 数字有没有6位, 如果没到6位,在前面用0补充, 这里面有一个布尔语法

price=0.5
print("商品价格是 %f"% price)
%.2f     意思就是输出小数点后面2位
```



## 逻辑,  判断, 循环

* if   如果
* ==tab别和空格键混用就行了==
* ==也注意一下, 类型不一样时不能比较的, 就比如下面的代码  加input  输入的就是字符串, 和18整型是不能比较的==

```
// if大胜利
age=19
if age>=18:
  print("你已经成年了")
else:
  print("你还没成年")
```



* 逻辑运算
* 逻辑运算用到逻辑运算符, and/ or / not

```
age=120
if age>=0 and age<=120:
  print("true")
else:
  print("false")
------------------------------------------------------------
布尔变量的逻辑运算
is_employee=false
if not is_employee:              // not嘛, 不是, 就输出,  很合理
  print("不准进入")
//out:  成功输出不准进入
```

* elif    
* elif 嘛,   很正常, 就是有了if,  但还需要增加条件, 这个条件还需要其他的一些代码,  那就加elif咯

```
holiday_name="Christmas"
if holiday_name == "valentain":
  print("xx")
  print("xxx")
elif holiday_name =="Christmas":
  print("sss")
  print("ss")
else:
  print("aa")
```

------------------------------------------------------------------------------------------------------------------------------------

* ==if的嵌套==
* 第一个if别满足后, 还有其他的条件需要满足
* 唯一注意的点就是   ==缩进==

```
if ssss:
  if aaa:
    if bbb:
```



----------------------------------------------------------------------------------------------------------------------------------------------------------

* 石头剪刀布的应用
* 这个应用很有启发, 什么启发呢, 就是没必要把所有的情况都写全
* 有些是非的情况, 这种二选一
* 完全就可不写非, 写一半是的, 留给else,  只要不是  是     , 就是非

```   
player=input("请输入")   //拳头1  剪刀2   布3
computer= 1     //这个电脑出的随机数,  这里是先预制, 实际上完全可以用1-3的随机数, import一个随机数库                   就行
                 computer=random.randint(1,3)
if (player ==1 and computer==2)or(player==2 and computer==3)or(player==3 and computer==1):
  print("win")
elif (player==computer):
  print("balance")
else:
  print("lose")
----------------------------------------------------------------------------------
随机数应用
import random
random.randint(a,b) 在a和b之间随机取数字, 包含a和b   整数!
```

----------------------------------------------------------------------------------------------------------------------------------------------------------------

* ==循环==
* while和for循环
* ==i的最重要的作用还是防止死循环==
* ==那啥赋值运算符, 了解一下就行了, 说实话, 这个记不住, 看了顺便查一查, 顺便记一记, 看代码量吧==
* 赋值运算符, 用的也就是    +=         -=

```
while 条件判断:
  xxx
  
i=1
while i<=5:
  print("hello")
  i=i+1        // 这就一普通的计数器, 连打印都没得资格   当然如果你硬要写的话, 还是有的
               // 好吧, 其实, i还有一种防止死循环的作用
print("循环结束后i的值: %d " % i)         //爷写了
```

* break和continue

```
i=1
while i<=10:
  if i==3:
    break
  print(i)
  i +=1
print("over")
//out:   1  2    over
# 这个break的意思呢,  就是到了一个条件后终止循环
------------------------------------------------------------------
continue就是继续呗
break终止循环了, 还想要原来的循环继续下去, 加个continue呗

i=0
whie i<10:
  if i==3:
    i+=1
    continue
  print(i)
  i+=1
//  如此out输出就不会有3了
```

-----------------------------------------------------------------------------

* 循环嵌套, 就是循环里面还有循环呗
* 啧啧, 还是ez的, 

```
row=1
while row<=5:
  col=1
  while col<=row:
    print("*",end="")
    col+=1
  row+=1
  print("第%d行"%row)
// 成功嵌套好吧, 无敌
// 主要还是学的这个思维, 因为col本身小于row, 所以这个内循环是基于row大小的
// 表面上我一个循环输出一个*  实际上, 针对row, 我输出了小于等于row的数
//  这个思维要学到, 循环内循环, 内循环是基于外循环的
----------------------------------------------------------------------------------
九九乘法表
row=1
while row<=9:
  col=1
  while col<=row:
    print("%d * %d=%d" % (col,row.col*row),end="")
    col+=1
  row+=1
  print("第%d行"%row)
```

* 主要学的还是嵌套循环的思维, 这个思维只能靠多磨, 多看, 多练了



## 函数の体验   (方法不是这个玩意儿, 这貌似是py特有的功能捏?)

* 函数就是懒人用法, 我不可能把已经实现功能的代码打一遍又一遍, 这太麻烦了
* 把实现功能的这些代码包起来, 用一个函数指明它,  这样的话, 如果我还想实现这个功能, 直接调用这个函数就行了
* 是不是很ez, 因为雀食很ez啊
* 代买包起来就叫封装       就是打包
* 定义函数和调用函数,   这是函数的两个用法咯

```
def  xx():          //def下面是要有四个空格的缩进的
    xxxx
    xxxx
    xxxx
这就是格式了
//  函数一般被定义在一个单独的文件, 想用它, 就import引用, 然后文件名加函数名()    就能用了
就是用文件里的方法呗,   还算ez
```

* 第一次の函数演练

```
// 这个函数定义完后,  需要调用才能用,  只要在这个def下的四格缩进里, 就代表被say_hello封装
def say_hello():
    print("hello 1")
    print("hello 2")
    print("hello 3")
    
say_hello()     // 调用, okay了, 就能运行了
```

* 函数の参数

```
def sum_2_num():
    // 对两个数字的求和
    num1=10
    num2=20
    result=num1+num2
    
    print("%d+%d=%d"% (num1,,num2,result))
    
sum_2_num()
// 上面的函数过于死板, 只能计算固定数值
// 这就要介绍到参数了 , 参数就是把外面的数字传到函数内部去
// 有了参数就完美解决了
------------------------------------------------------------------------------------
def sum_2_num(num1,num2):
   result=num1+num2
   print("%d+%d=%d"%(num1,num2,result))
   
sum_2_num(50,20)
```

* 解释下形参和实参
* 形参就是定义用的num1, num2
* 实参就是调用用的50和20
* 就这么简单    形参形参 就是没有具体数字咯,   实参就是有实体,  有具体数字

------------------------

* 返回值

```
def sum_2_num(num1,num2):
    result=num1+num2
    return result           // 怎么感觉这个return是来代替print输出的
    
sum_result=sum_2_num()
print("计算结果是%d"%sum_result)
```

* return 的真正作用应该就是是用来代替print输出的
* return也有结尾的作用,    译为函数的结尾

---------------

* 函数的嵌套调用    啊对对   就是循环の函数变种
* 就是在一个函数调用里面调用函数 

```
def test1():
    print("xxxx")
    
def test2():
    print("sssss")
    test1()
    
test2()
//  调用了test2()函数,  同时也执行了test1()
// 在函数里调用函数后,   没有return的功能, 也就是后面的代码也会被执行
```



## 模块的用法

* 模块就是个大工具包, 里面有各种各样的工具,  比如已经被定义的函数
* 模块还有个非常重要的作用:  ==就是全局变量赋予==
* ==全局变量就是统一的数据, 想要引入某一个主运行程序的数据统合==
* 调用模块很简单,  直接import就好   // 想起什么了吗, 就是调用函数那节讲的东西
* 函数本身被封装在了一个文件里, ==import那个文件, 文件名加函数名()   是他的调用方法==
* 模块就是.py结尾的文件

------------------------

## 高级变量类型

### 列表

* List    在其他语言里通常称为数组 (array)
* 专门用来存储  一串信息
* []定义          ,分割
* 索引 从 0 开始

* 列表其实就是  ==一个变量存储多串信息==

```python
name_list=["www","sss","ffff"]
```

* 列表是从零开始计数编号的

``` 
取出列表中的某个信息, 就是把对应的编号打上就行
name_list[0]                //取值
print(name_list)
----输出了www
================================================================
name_list=[]     // 这是定义了一个列表变量, 列表里没有任何数据
name_list.index("sss")
print(name_lsit.index("sss"))     //这就是索引, 所谓索引, 就是知道数据内容, 但不知道数据存在哪儿  
--- 输出了 1          //sss的编号
===================================================================
name_list[1]="aaaa"        // 这就是修改列表里的内容
                           // 这个修改只能修改列表里已有的编号, 编号外的数据是不能增加的
                           // 也就是说添加是其他方法实现的
name_list.append("bbb")    // append方法向列表的末尾追加数据
name_list.insert(1,"ddd") // 在编号1 上插入数据, 原编号1的数据只能往后挤了,后面都往后面挤一格

temp_list=["111"]
name_list.extend(temp.list)   //extend  就是把一个列表的所有数据插入进另一个列表里,从末尾添加
================================================================================
name_list.remove("sss")      // remove方法可以从列表中删除指定数据
                             // 如果要删除的数据存在多次, 只会删除第一次
name_list.pop()              // pop默认情况下, 会把列表中最后一个元素删除
name_list.pop(3)            // pop可以指定删除索引对应的数据
name_list.clear()           // 清空列表
===============================================================================
用关键字对列表内容进行删除
del name_list[1]            //删除了指定索引对应的数据
//  del关键字   本质上是用来将一个变量从内存中删除
name="小明"
del name                 // name这个变量被删除了
============================================================================
得到列表长度的方法很简单, 但输出  // 这个 其实困扰了我很久
//  为什么有的直接使用方法就能在print输出, 有的需要另外给一个变量,将数据传进去
//  这应该是方法的应用问题,   将变量包裹的方法, 一般都需要赋予一个变量
//  行吧, 问题不是出在方法的应用上,  这个重新赋予变量应该有更多的意思
//  比如后续我还需要这个数据, 为了方便引用, 我给一个变量,让他专门存储这个数据
len(name_list)           //这其实就行了, 已经测完了列表的长度, 但没法输出
list_len =len(name_list)
print(list_len)          // 赋予了新变量,输出了列表长度

count = name_list.count("aaa")        // 统计列表中某一个数据出现的次数
print(count)                          //输出
===========================================================================
name_list = ["zhangsan","lisi","wangwu","wangxiaoer"]
num_list =[6,8,4,1,10]
name_list.sort()            // sort的方法就是升序排序, 排下来按英文字母abcd排序
num_list.sort()             // 这是按数字大小排

name_list.sort(reverse=True)         //sort方法内部有一个布尔判断, false是升序, true是降序
num_list.sort(reverse=True)          //同上

name_list.reverse()           //  翻转, 就是 把原来列表的排序倒着来一遍
num_list.reverse()            //  时空反转!!!

print(name_list)              //输出用的
print(num_list)               //输出用的
```

* 下面是循环遍历的用法, 也就for循环
* 所以for循环是用来给列表准备的?

```
name_list = ["zhangsan","lisi","wangwu"]
for my_name in name_list:                   // 这里的my_name 是现取的变量
    print("我的名字叫 %s" % my_name)          // 大部分情况下, my_name 这个位置是 i
                                           // 这里其实解释了我很久前的疑惑
                                           //就是 i 这个cjb到底是啥玩意儿
                                           //计数器???
```



### 元组

* 元组(Tuple)  与列表类似
* ==但元组不能修改!==
* 元组是由多个元素组成的序列
*  用()定义

```
info_tuple =("zhangsan",18,1.75)
info_tuple[0]                 // 索引
info_tuple=()                // 创建空元组
info_tuple=(50,)              // 一定要加逗号, 元组可以存放不同类型的数据, 只输入50,会被认定为                                 int类型, 加了逗号, 才能被认定为元组
===================================================================
print(info_tuple.index("zhangsan"))        //取索引
print(info_tuple.count("zhangsan"))        //计数, zhangsan在列表里出现的次数
print(len(info_tuple))                     //输出元组长度
=====================================================================
for my_info in info_tuple:
    print(my_info)
// 输出了元组的数据  
//   实际开发中, 因为元组存的数据不一样,所以用到循环元组的机会并不多
========================================================================
```

* 在py中, 用for循环可以循环所有非数字型类型的变量: 列表, 元组,字典, 字符串
* 元组的应用场景:  !!!!!!!!!
* 元组可以用来当函数的参数和返回值        用元组的形式输入参数,  返回返回值
* 格式化字符串(本质上就是一个元组)
* 让列表不被篡改(保护数据)

```
// 让列表和元组相互转换
list(元组名)
tuple(列表名)
记得转换的时候 ,要新写个变量 来存储被转换后的数据
```



### 字典

* 字典(dictionary),     列表外最灵活的数据类型,  一样可以存储多个数据
* ==通常是用来存储描述一个物体的相关信息==
* 字典是无序的集合==无序的意思就是, 字典输出的时候,和定义好的排序不一样==     用{}定义
* 键(key)值(value)对,   这是字典存储的数据的格式,    与关系型数据库很相似
* 键值对间用逗号分隔,   键和值之间用:分隔
* 键只能是: 字符串, 数字,元组       值可以是任何数据

```
xianming_dict ={"name":"小明",
           "age":18,
           "gender":True,
           "height":1.75}
============================================================================
xiaoming_dict["name"]              //因为字典本身是无序的,也就没有编号,取值需要把key打出来
print(xiaoming_dict["name"])    //输出咯

xiaoming_dict["age"]=18                      //增添了键值对
xiaoming_dict["name"]="小小明"               //修改里面的值

xiaoming_dict.pop("name")               //删除键值对

len(xiaoming_dict)                    //统计键值对数量

temp_dict ={"height":1.75}
xiaoming_dict.update(temp_dict)     //合并字典

xiaoming_dict.clear()               //清空字典

// 字典的迭代循环比较特殊
// 每次字典的迭代循环其实拿到的是key, 没有value被掏出
// 以下是经典字典循环的套路
for k in xiaoming_dict:
   print("%s - %s" % (k,xiaoming[k]))             // 思路还是很清晰的,套用的索引加迭代的特性
```



## 公共方法

* 公共方法, 所谓公共, 就是大家都能用咯
* 元组, 列表, 字符串, 字典都能用的方法就是公共方法

```
len(item)          len(a)      // 统计长度
del(item)          del (a)   /  del a[1]     //删除变量和删除特定函数的索引
max(item)          max(a)      //  统计最大值,就是一串字符或者数字的最大值
min(item)          min(a)      //  统计最小值, 同上

// 高级数据类型的切片
[0,1,2,3,4] [1:3]        //从1开始砍, 到3前截止, 不包括3
(0,1,2,3,4) [1:3]        // 同上
字典没索引概念, 不能切片


//算数运算符的应用
[1,2] *2
-----[1,2,1,2]
(1,2)*2
-----(1,2,1,2)
字典不支持乘号
[1,2]+[3,4]
-----[1,2,3,4]        //元组同理

// 成员运算符
// in 和 not in
1 in [0,1,2]
----True
1 not in [0,1,2]
----False

============================================================================
// 完整的for循环语法
for  变量  in  集合:          //这里最重要的就是  for后面跟的是变量
    循环体代码
else:
    代码xxx
    

// 利用for else搜索字典列表
students =[
     {"name":"小美"},
     {"name":"阿土"}
                     ]
find_name="xx"                             // 这就是为了区分写的
for stu_dict in students :
    print(stu_dict)
    if stu_dict["name"] == find_name :         // 遍历的是字典,所以for后面的变量实际为字典
        print("找到了 %s" % find_name)
        break                          // 这里是重点, break应该具有退出循环之意,所以搁哪儿都行
else:
    print("没找着")
```





## 名片管理系统项目实操

* 一切代码和问题全部在名片管理文件夹下, 自己找吧
* 我只能说, 思维这玩意儿,  还是得好好悟
* 应该是代码量的问题
* 交给时间吧, 我也只能把这些天的感悟记下来了, 尽人事, 绝天命.

## 变量详解

* 变量实际上是一个引用体系
* 数据被程序存储在内存的一个地方,  变量就是贴在这个数据的标签,  上面记录着数据存储的地址
* 不管引用来引用去,    b=a=1        b和a的本质是一样的, 是关于1的存储地址

-------------

* 下面是全局变量和局部变量的区别
* 局部变量,   顾名思义, 就是只存在于一个局部的变量
* 举个例子, 我在tools.py下分别写数个函数,  但是我在这数个函数里都设置了同名的变量
* 而这些同名的变量并不能在这数个函数里通用,  只能分别在自己的函数里使用
* 全局变量就是定义在函数之前,  能够被数个函数通用的变量

-----------



## 函数高级

* 函数参数和返回值

* 参数就是外界希望函数处理的数值,   就是输入进函数进行运算的数

* 返回值就是函数的执行结果,  将结果数值返回

  ```
  def measure():
     """测量温度和湿度"""
     print("测量开始")
     temp=19
     wetness=50
     print("测量结束")
     return (temp,wetness)      //这可不就是元组吗, 我特码还想着定义一个元组,然后添加进去,焯
  
  result=measure()
  print(result)
  
  # 下面解决一个问题, 就是返回一个元组, 想要很方便快捷的单独处理元组中的元素
  # 方法如下
  gl_temp,gl_wetness=measure()          //gl 是全局变量的标识符, 这表示这两个玩意儿是全局变量
  
  print(gl_temp)
  print(gl_wetness)
  ```

  ```
  # 交换两个数字
  a=6
  b=100
  
  # 解法1 使用其他变量
  c=b
  b=a
  a=c
  
  # 解法2
  a=a+b
  b=a-b
  a=a-b      
                      //  惊为天人, 焯, 我的数学雀食拉中拉
  # 解法3
  a,b=(b,a)      // 这就是单纯的元组特性了, 应该是完全的交换, 单独调试看一下数据的来源
  // 这是刚才的用法, 就是那个全局变量的用法,  这好像是元组可以使用的快捷传输数据
  // 如果没有猜错, 列表也是可以的, 字典应该不行
  ```

---------------

### 函数的参数

```
def demo(num):
    print("函数内部的代码")
    num=100
    print(num)
    print("函数执行完成")
    
gl_num=99
demo(gl_num)
print(gl_num)
----------- 输出了 100, 99
----------- demo(gl_num)  在函数内部, num由重新赋值100 ,然后输出100
----------- 但在函数内部被修改, 只是这个函数内部的数, 在外面, gl_num并没有被修改
----------- 他还是输出了99
// 也就是 外部参数在函数内部被重新赋值, 并不会修改外部参数的值
===========================================================================
def demo(num_list):
   print("")
   num_list.append(9)
   print(num_list)
   print("函数执行完成")
   
gl_list=[1,2,3]
demo(gl_list)
print(gl_list)
----------  输出了两个[1,2,3,9]
// 我的理解就是方法可能是直接在原地址上增加了9 ,而不是另开一个新地址存一个新列表
// 也就是说, 在函数内部使用方法, 是可以修改全局变量的
```

-------------------

### 缺省参数  就是函数一开始有了默认值

* 所谓缺省参数, 就是在定义函数的时候,  给某个参数值一个默认值,  具有默认值的参数就叫缺省参数
* 调用参数时,  如果没有传入给缺省参数的值,  就可以直接使用默认值
* 举个例子, 就比如列表的升序降序
* list.resort()    这是默认升序的操作,   这就是缺省参数的应用, 默认升序
* 想要降序, 就需要  list.resort(reverse=True)

```
def print_info(name,gender):
   gender_text="male"
   if not gender:                   //gender应该是个变量名, 这个gender并没有一开始的Boolean属                                       性
                                    // 这应该是not 带给它的boolean
     gender_text="female"
     
   print(xxxxx)
print_info(ming,True)
```

* 缺省参数的重要注意事项
* ==就是定义函数的时候,  如果函数里面有缺省参数,   这个缺省参数应该放在参数最后==

--------------

### 多值参数 以后再说 ,用到再说,   这玩意八百年感觉都用不上



## 递归

* 所谓递归,   最通俗的解释就是,    ==在一个函数内部, 自己调用自己==
* 递归就是  ==压栈逐层返回==
* ==函数内部可以调用自己!!==
* 特点:      就是函数内部代码相同,  只是参数不同
* ==最重要的是,  递归一定需要一个出口, 就是一个停止条件, 不然无限递归循环下去会崩溃==

```
def sum_number(num):
    print(num)
    
    #  这就是递归的停止条件了 , 说实话这个return简直神来之笔, 不用break, 应该是break只有跳出循环之        意
    #  而return具有结束函数之意,  还是要好好学习return的骚操作
    if num ==1:
       return
    # 自己调用自己
    sum_number(num-1)
    
sum_number(3)
```

```
def sum_numbers(num):
    # 这是个出口
    if num ==1:
      return 1
    
    
    #  所以temp本质上是一串加法的集合, 就是 1+++++num-1 为止, 真的哈人, 感觉人脑其实反应不过来
    #  数字上的直观到一串加法集合体, 这种计算机式的抽象
    # 后来想了下, 这个递归一直到1为止, 并且返回1, 然后依次返回, 所以成就了一个集合
    #  也就是说在数学表达上, 这个集合体实质上是1+2+3+4.....+num-1+num
    temp = sum_numbers(num-1)
    
    
    # 两数相加
    return num+temp
```





## 面向对象(oop)

### 面向过程的基本概念

* 就是开发函数, 将一些功能独立的代码封装成一个有一个的函数
* 最后完成的代码, 就是==顺序地==调用不同的函数
* 如果需求复杂,  代码将会变得很复杂
* 这种面向过程, ==面对复杂项目==没有固定套路,  开发难度很大

### 面向对象

* ==是有固定套路的==
* 比如这种思维模式
* 接到一个需求,  确定 **职责(要做的事情---方法)**,  根据 **职责确定不同的对象**,  在 **对象内部封装不同的方法**
* 最后完成的代码 ,  就是顺序地让 **不同对象** 调用**不同的方法**

---------------

* 注重 **对象和职责** ,  不同的对象承担不同的职责
* 对,  对复杂项目开发,  有固定的套路
* 再多学点特定的  面向对象  语法就行

------------------------------

* 面向对象核心概念,    一个是类,    一个就是对象
* 先有类, 后有对象,      也就是类是对象相同点的集中,  就是一个抽象范围
* ==**飞机是一个大类:   战斗机,  客机, 轰炸机, 水上飞机(对象)**==
* 类和对象都有两种 :    属性和方法
* ==对象直接继承类的属性和方法==
* dir  这个内置函数, 可以查看任何一个对象的属性和方法,   我暂且蒙古

-----------------------------------------

## 面向对象基础语法

* 面向对象实际上就是一个更大的封装,   一个类中封装多个方法,  通过这个类创建的对象就可以直接调用方法

```
// 创建包含方法的类
class 类名:
  def 方法1(self,参数列表):           // 这个self是必须有的,这是区分函数和方法
    xxx
  def 方法2(self,参数列表):           //  必须有self  self是自己的意思
    xxx
    
    
// 创建对象
对象变量=类名()
```

```
// 第一个面向对象程序
// 需求: 小猫爱吃鱼, 小猫要喝水
class Cat:
  def eat(self):
    print("小猫爱吃鱼")
  def drink(self):
    print("小猫要喝水")

# 创建对象, 并让对象使用方法
tom =Cat()

tom.eat()
tom.drink()
```

```
//  进阶扩展
class Cat:
   def eat(self)
     print("%s 爱吃鱼"% self.name)
     //   也就是说self, 其实那个对象调用的这个方法, self就是谁
     // 相当于贴了个标签, 比如上面的tom引用了,  self就是tom吗
     // 当然类里并没有name,  所以这个输出肯定会报错, 所以要加这个name
     
     
     // 所以要重置,  初始化方法
     
__init__    针对对象使用的内置方法
这个方法  是专门用来定义一个类具有哪些属性的方法
```

```
__init__    就是定义属性的工具
这个方法是用来定义类里的属性的,  这个一定要搞清楚

class Cat:
  def __init__ (self):
    print("这是一个初始化的方法")
    
    self.name = "Tom"     // 定义了属性, 只要使用Cat类创建的对象, 都会有这个属性
    
  def eat(self):
    print("%s吃鱼" % self.name)      //这是为了体现上述说的真实性, 也就说会输出name
    
tom= Cat()
tom.eat()
print(tom.name)
```

```
改造__init__方法
就是引入形参和实参咯
class Cat:
  def __init__ (self,new_name):
    print("这是一个初始化的方法")
    
    self.name = new_name     // 赋值给了new_name咯  形参
    
  def eat(self):
    print("%s吃鱼" % self.name)
    
    
tom=Cat("Tom")
lazy_cat=Cat("大懒猫")
直接就,  每一个对象都可以继承属性也可以覆盖属性
这好用
```

* **==也就是init方法纯纯的就是给类定义属性的工具==**

### 面向对象の初级实战演练

* **封装**是面向对象的一大特点
* 面向对象第一步,  就是将属性和方法封装到类里
* 外界使用类创建对象,   然后让**对象调用方法**
* 对象方法的细节就被封装到类里了

```
class Person:
  def __init__(self,name,weight):
    
    # 形参就是形参,  name这个值到时被对象用到的时候,自然会变实参,然后name不就输入进去了
    self.name=name
    self.weight=weight
    
  # str是一个快速输出的方法,  注意一下这个str方法必须要有返回值
  def __str__(self):
    return "我的名字是%s,体重是%s公斤" % (self.name,self.weight)
    
  def run(self):
    print("xxxx")
    
    self.weight -=0.5           // 就是这个self.weight会随着更新而更新   updating
    
  def eat(self):
    print("xxx")
    
    self.weight +=1              // updating 
    
xiaoming=Person("小明",75.0)
xiaoming.run()
xiaoming.eat()

print(xiaoming)      // str的方法使用
```

* 再进阶的案例





-------------------------

```
class HouseItem:
  def __init__(self,name,area):
    self.name=name
    self.area=area
    
  def __str__(self):
    return "[%s] 占地 %.2f"% (self.name,self.area)
    
bed =HouseItem("席梦思",4)
chest=HouseItem("衣柜",2)
table=HouseItem("餐桌",1.5)

print(bed)
print(chest)
print(table)



class House:
  # 形参的设计也是很有选择的, 就比如我为啥不选空列表去做形参
  # 就等于还是在里面又做了一个选择的选择
  # 需要外部指定数值, 就列形参,   不需要的, 直接在方法内部定义
  def __init__(self,house_type,area):
    self.house_type=house_type
    self.area=area
    
    # 剩余面积
    self.free_area=area
    # 家具名称列表
    self.item_list=[]
    
  def __str__(self):
    
    # py可以将在小括号内部的代码连接在一起
    return ("户型: %s\n 总面积xxxx")
    //  反正就是格式化输出, 不重要
    
  def add_item(self,item):
    
    print("要添加%s" % item)
    
    
my_home=House()

my_home.add_item(bed)
my_home.add_item(chest)
my_home.add_item(table)      // 也就是实际上,这个对象是被传进去了, 但为什么item输出的item.name
                            // 而且逻辑上好像没有吧列表加紧self.item_list里
                            // 等下一步优化
                            
====================== 优化方案如下================
add_item方法的迭代
#  需要判断家具的面积, 不能大于总面积
#  家具的名称要添加到列表里
#  计算剩余面积

def add_item(self,item):        // 也就是说,这个对象传入进去, 对象里本身的方法是还能用的
  
  
  # ?? item.area 啧啧, 这就是对象方法还能用, 也就是不同类是可以用的, 但这个类的顺序是否要注意下呢?
  
  if item.area > self.free_area():
    print("家具太大,无法添加")
    
    return    // 这就直接不执行了, 雀食, 家具太大放不进去, 很正常
  
  #  最后传入列表的实际上只是个name
  self.item_list.append(item.name)
  
  # 计算剩余面价
  self.free_area -= item.area
    
    
```

* 下面是封装案例

---------------

* 其实主要还是体验下,  有多个类,    而一个**对象**的属性  可以是  **另一个类创建的对象**
* 这句很难理解,   我暂时理解不能
* 这里我突然明悟一个东西,   那就是类属性无论是否为形参, 都是在__init__方法里

```
class Gun:
  def __init__(self,model):
    self.model=model
    
    self.bullet_count=0
    
  def add_bullet(self,count):
    self.bullet_count += count
    
  def shoot(self):
    
    # 1. 判断子弹数量
    if self.bullet_count <= 0:
      print("xxx")
      return
      
    # 发射子弹
    self.bullet_count -=1
    
    # 发射子弹信息
    print(xxxxxxxxxxxxxxx)
    
    
    
class Soldier:
  def __init__(self,name):
    # 姓名
    self.name= name
    # 士兵一开始是没枪的
    self.gun=None
    
  def fire(self):
    
    # 判断士兵是否有枪
    if self.gun == None:
      return
    
    
    
    # 装填并开火
    self.gun.add_bullet(50)              //调用了gun类的方法
    self.gun.shoot()                     
    
    
ak47=Gun("AK47")

xusanduo=Soldier("许三多")

xusanduo.gun=ak47          // 这就是给枪?了
                           // 结果上看, 创建ak对象, 然后把对象赋值给xusanduo的gun
                           // gun是xusanduo这个对象的属性, 本来是none
                           // 现在有了, 然后既可以调用ak这个对象的方法

xusanduo.gan.fire()

print(xusanduo.gun)
```

* 这里是有个补充的  就是**None**关键字,  如果写类的时候, 不知道给属性定义一个什么参数值, 就写个None
* 说实话 这两个类相互调用还挺乱了,   慢慢来,  总会突然想通的



### 私有属性和方法

* 就是有些时候     对象的某些属性和方法, 只能在**对象内部被使用**, 不希望被**外部访问到**

* 就是隐藏的,    不希望公开
* **private**

```
private 很简单,  就是前面加两个下划线  __
这就是私有属性了


class Women:
  def __init__(self,name):
    self.name=name
    
    # 私有
    self.__age=18
    
  def secret(self):
    print(self.__age)
    
    
xiaofang=Women()
xiaofang.secret()

print(xiaofang.__age)    // 这个就不会被访问, 也就是直接打印是不可能输出私有属性的, 只能靠方法
# 写了方法,   私有属性会被外界直接访问的
```

-------------------



### 继承

* **继承**  就是实现**代码复用**,   相同的代码不需要重复的编写
* 感觉像  **函数**

```
class Animal:
  def eat(self):
    pass
  def drink(self):
    pass
  def run(self):
    pass
  def sleep(self):
    pass
 
 # 继承了Animal,  Animal是父类
 class Dog(Animal):
```

* 注意一下  **class  xx(父类名):**   这就是继承的语法
* ==子类拥有父类所有属性和方法==
* 然后子类根据自己的需要,    **封装自己特有的属性和方法**
* **如果存在父类的父类的话,    那么子类也会有爷类的属性和方法**

-----------------------------------------

### 继承の 方法重写

* 就是子类不是有父类的属性和方法吗,     就父类的方法用的不合心意呗,   那就要重写
* **子类方法重写覆盖父类方法**

```
class Dog:
  def eat(self):
   xx
  def bark(self):
   xx
   
class Xiaotianquan(Dog):
  
  def bark(self):
   ss
   
 //  也就是py很简单粗暴,  如果父类的某个方法不合心意,  直接在子类里重新写一下就行
```

--------------------



* 下面是另一种 对**父类方法的重写方式**
* 就是一种扩展
* ==就是父类的方法用的上,  但是不全,  重写太麻烦, 想在原来基础上写==

```
class Dog:
  def eat(self):
   xx
  def bark(self):
   xx
   
class Xiaotianquan(Dog):
  
  def bark(self):
   print("xxx")      //子类重写需要的输出
   
   super().bark()     // 这是父类方法的使用,  也就是说父类方法的输出会在这里输出一遍
   
   print("xxxx")
```

* super  实际上是一个==**类**==
* super().父类方法     来调用父类方法的执行
* ==super()    就是使用super类创建的对象==
* 最常使用的场景,   就是在==重写父类方法时,  调用父类中封装的方法==

---------------------

### 私有属性和方法的扩展

* 我们知道私有属性和方法,   是不能直接被外界访问的
* 同理,   ==实际上父类的私有属性和方法也不会被子类访问和调用==

* 当然子类  可以用过父类的公有方法间接访问私有属性和方法的    前提是这个公有方法有访问私有属性和方法



-----------------------

## 多继承

* 子类是可以拥有多个父类的,     并且具有所有父类的属性和方法

```
# 当然 py吗,   不要觉得多复杂,  还是很简单, 多继承吗
# 单继承思路是括号里写一个父类名,   那很多个父类,  就在括号里都写上呗

class 子类名(父类名1, 父类名2, 父类名3...):
  pass
  
class A:
  def test(self):
    pass
    
class B:
  def demo(self):
    pass
    
class C(A,B):
  pass
  
  
# 调用咯, 反正C有A和B两个类的属性和方法
C.test()
C.demo()
```

* 当然 加入多个类里面的方法和属性有重名的,   那就要谨慎使用了

* 遇到**使用重名方法,    是按括号里父类名的顺序来决定使用哪个方法的**
* 解释型语言吗,    反正**从上到下运行**

---------------------------------

## 多态

* 这是**面向对象开发的最后一个特性**
* 也是一个我**学java时很懵逼的特性**,     这里慢慢学吧,  语言这玩意儿一通百通
* 顶多**其他语言有点小特性需要认识一下,    这里基本的开发思路是老早定死的**

-------------

* 合着多态就是**子类重写父类方法啊?**,    这就是增加代码灵活度吗,  爱了爱了,  怪不得只有学基础才提
* 焯!!!!!!!!!!
* 多态的前提是   **继承和重写方法**
* 多态的本质是   **不同子类对象调用相同的父类方法, 产生的不同结果**
* 比如     **人类是一个大类, 需要工作,  但子类程序员和老师, 他们工作的内容就不同**

```
class Dog(object):
  def __init__(self,name):
    self.name=name
    
  def game(self):
    print("玩")
    
class XiaoTianDog(Dog):
  def game(self):
    print("神狗玩")
    
    
class Person(object):
  def __init__(self,name):
    self.nname=name
    
  #   这里需要重点说一下,   这个方法是和狗类  互动的关键,  也就是把狗类对象直接传入到这个方法的参数了
  def game_with_dog(self,dog):
    print("play with %s" % dog.name)
    
    # 让狗玩
    dog.game()
    
wangcai=XiaoTianDog("wangcai")
xiaoming=Person("小明")

xiaoming.game_with_dog(wangcai)      // 这就是把对象给输入进去了
```

* 这里主要还是掌握的   **两个类** **到底是如何进行互动的**     
* 其实说到底 , 还是两个对象进行互动    怎么互动,   用**方法**
* 要把**一个对象当做参数传入另一个对象的方法里**

------------

## 类专属属性和方法 术语解释, 对象方法属性的保存原理  内存的高效运用

* 创建出来的  **对象**  叫做  **类的实例**
* 创建对象的动作  叫做 **实例化**
* **对象的属性**   叫做   **实例属性**
* **对象调用的方法**  叫做   **实例方法**

---------------

* 使用类名创建对象         **内存会为对象分配空间**
* init方法 就是给类定义属性的
* 属性,  类属性会被对象继承,   **对象的属性 会随类 存储在对象的空间里**
* 但 对象的方法不会,  **除非是重写方法,   不然继承自父类的方法,  方法依然会存在父类里**
* 也就是说  为了节省 空间  方法只保存一份    除非重写,   不然不会另外分配空间
* 这里就是**self**  字的用法,   self  就是给对象实现注入的,    这也是方法可以只保存一份的关键技术
* self的用法   就是为了节省空间的,    是为了给对象注入的

--------------------------

* 这里讲一讲类属性的事,  也就是说,  init方法是给类的初始属性的
* 有些时候 ,**类也要有自己的特征**,     当然类属性不会记录创建对象的具体特征



* 下面是需求,    定义一个工具类,  想要知道**使用这个类创建了多少对象**
* 这就需要类属性了

```
class Tool(object):

  count = 0                    //这就是最简单的类属性了,   计数用的

  def __init__(self,name):
    self.name=name
    
    Tool.count +=1             // 每调用一次初始方法,  都会加1   很简单遍历运用
                               // 当然还是很疑惑, 为什么会给他加1
                               
                               
print(Tool.count)
```



----------------

* 下面是类方法环节
* 就是想要给这个类加上特征的方法呗,   属性都有了, 方法算啥呢

```
# 下面是类方法的语法结果,   就是这么写就完事

class 类名(object):
  @classmethod                      //这里就和java一样,  要写个提示, 这是类方法
  def  类方法名(cls):                // 里面不写self的, 这又不是给对象留传入位置
    pass
```

```
class Tool(object):
  count +=1
  
  @classmethod
  def show_tool_count(cls):
    
    print("工具对象的数量 %d" % cls.count)
  
  def __init__(self,name):
    self.name=name
    
    Tool.count +=1
    
    
tool1=Tool("斧头")

Tool.show_tool_count()        // 也就是说这个类方法最特别的就是  不需要new对象
                              // 直接就是用类名类方法调用了
```

-----------------

## 静态方法

* 静态方法就是一种很特别的方法
* **既不需要访问实例属性和方法,   也不需要访问类属性和方法**
* ==当然静态方法只是不会访问其他属性,     没说不可以传入参数啊==

```
# 静态方法的语法

class Dog(object):

  @staticmethod                // 要写@staticmethod
  def run():                   //  既然什么属性都不要, 那就不用加self了
    
    # 不访问实例属性
    print("小狗要跑...")
    
    
# 调用很简单, 就是类方法的调用方式
Dog.run()

```

---------------



## 方法综合案例 演练

* 已知有三种方法
* 类方法,  实例方法,   静态方法

-----------

* 现在有需求

​                            设计一个game类

* 属性有两个, 一个类属性--要记录游戏的最高分,    一个实例属性-----当前的玩家游戏名字
* 方法有三个
* 静态方法  -------- 用来显示游戏帮助信息     ==这里很重要,  静态方法不访问任何属性和方法,所以可以这么用==
* 类方法  --------   显示历史最高分
* 实例方法  --------  开始游戏,  游戏玩家账号登入

```
# 下面开始设计game类

class Game(object):
  
  # 历史最高分
  top_score = 0
  
  @staticmethod
  def show_help():
    print("帮助信息, 让僵尸进入大门")
    
  @classmethod
  def show_top_score(cls):
    print("历史记录 %d" % cls.top_score)
    
  def __init__(self,name):
    self.name=name
    
  def start_game(self):
    print("%s 玩家开始游戏" % self.name)
    
    
# 查看游戏帮助
Game.show_help()
# 显示最高分数
Game.show_top_score()
# 玩家开始游戏
xiaoming=Game("xiaoming")
xiaoming.start_game()
```

* 下面是案例小结,  就是如何迅速划分方法,  静态方法和类方法的活灵活用

----------------------

* 这种游戏帮助, 又不需要输入外部参数, 也不需要访问类属性,   就完全可以调成静态方法吗
* 那种类属性,   就是方法使用过的计数啊,   方法达成的结果计数啊,     就可以用类属性, 类方法输出



--------------------

## 单例设计模式   (***)[可以说设计代码很重要了]

* 这节有点重要,    **设计 模式是规划代码的思维套路**
* 就**比如上面的游戏帮助, 我可以设计为静态方法**
* 这种设计模式会被广泛地运用,    在以后设计架构时, 会搞一些**MVC设计模式这类的**
* **面向对象之所以流行,  除了够简单,  类和方法完全碾压函数外,   这些套路的设计模式也是很重要的**

--------------

* 下面是单例设计模式的思路
* 单例设计模式的目的-------让**类创建的对象**,在系统中只有**唯一的一个实例**
* 就是每一次类名()返回的对象,  **内存地址都是相同的**
* 内存地址都是相同的  ====    **说明每一次的对象都是同一个 **
* 单例设计模式的应用:   音乐播放器(每次只放一首歌) ;     回收站 (一个系统里只有一个回收站)



### new方法(是一个静态方法!!   这意味着这是不会访问任何属性的,除非主动传递)

* 两个下划线在开头和结尾的,  这代表这个方法是内置方法  就比如 init和new
* **new方法是在每一个类创立时就默认启动了**,    **写的new方法都是重写**
* **new方法本身就好像是为单例设计模式  设计的**
* **new方法的主要作用是为对象分配空间**,    **init方法是让对象初始化**
* 在用了new方法后,  对象创建会给py解释器返回一个空间,     并且从始至终,   无论多少次创建多少个对象, 对象空间就这一个
* 一般用new方法,   会传递  **cls参数**  进入      ,    new方法本身有三个参数
* 重写new 方法一定要写**return!!!**
* 没返回, 是不知道到底分配哪里的内存空间的

```
# 下面是__new__方法的重写演练

class MusicPlayer(object):
  
  # 开始 重写 new 方法
      // 这里要注意, 在用new方法时, 这后面三个形参是自动跳出来的, 意思是可以被传入
      //  *一个星号的, 是可以被传入元组,    **两个星号的, 是可以被传入字典
  def __new__(cls,*args,**kwargs):
    
    # 每次创建对象的时候, new方法都会被默认调用
    # new就是干的分配对象空间的活
    # 这个在c里面   空间是可以被指定的
    print("创建对象, 分配空间")       //用这句打印来验证每次都会被调用
    
    # 为对象分配空间,  这个方法不需要写, new方法本身就有分配空间的功能,  直接调用父类方法就好
    # 但问题是, 我们想要指定一个  固定的分配空间  
    # 所以 我们可以设置一个变量,  用一个变量固定存储返回的空间,  这就实现固定功能了
    instance = super().__new__(cls)
    
    # 下面是  __new__ 方法一定要带的   返回!!
    return instance
    
  def __init__(self):
    print("播放器初始化")
    
player = MusicPlayer()
print(player)        //不仅会输出播放器初始化,  也会输出内存地址(被指定的)

```

* 下面是单例设计模式做的  进阶案例

---------------------------------

```
 # 单例进阶  就是想要初始化动作,   就是那个init方法只执行一次
 # 无论创建多少个对象,  init方法只执行一次
 
 class MusicPlayer(object):
   
   # 定义这个类属性不为别的,  就是为了记录 init方法 的引用
   instance =None
   
   init_flag=False
   
   def __new__ (cls,*args,**kwargs):
     
     # 判断一下类属性有没有被赋值, 没有就给赋值
     if cls.instance is None:
       cls.instance = super().__new__()
       
     return cls.instance
     
   def __init__(self):
     
     # 判断有没有执行过初始化动作
     # 若执行就返回, 终止方法
     # 若没执行, 再执行初始化动作,  修改类属性的 True
     if MusicPlayer.init_flag:      // 这里有个小技巧, 就是这样写, 是默认判断是否True的
       return
     print("初始化")
     
     MusicPlayer.instance = True
     

```

* 这里需要记录一下思路,    就是以后想**加个次数限制, 完全就可以这样,   用布尔判断**
* 在 **到达 指定次数前,  都是False   ,   到了指定次数,    就是True**



---------------------

## 异常 (这个概念我在java里学的也是不清不楚的,  重点注意一下  )

* 异常,   很常见,  就是程序碰见了异常,   会执行不下去, 终止执行 ,  并且提示一下错误信息
* **程序停止执行, 并且显示错误信息**,     针对这个行为,   我们叫做 **抛出(raise)异常**
* 程序开发时, 很容易遇到异常,      遇到这些异常或某些特殊情况,   就可以**异常捕获**, 集中处理

```
# 下面是常见的异常错误

num = int(input("请输入整数"))

print(num)

//  如果输入的不是整数,   输入字母,  程序就会报错,  就会终止运行对不对
//  这里就需要捕获异常了
```

* 异常的作用, **就像qq登录输错的密码提示**, 当遇到会使程序终止的错误, **就会进行提示**
* 也就是异常的作用,   就是提醒信息, 遇到错误并抛出, 指示修改, 然后使程序正确执行
* 就是**输入错玩意了, 程序执行不了, 给你个提示,  让你正确执行**

```
# 下面是异常捕获的代码
# 很简单的基本语法


# 如果对某些程序代码执行的正确性存疑,   那就把你觉得 可能会出问题的代码 放进去

try:
  num = int(input("请输入一个整数"))


# except 的作用就是那种 , 如果程序遇到错误了, 该执行什么代码
except:
  print("请输入正确的整数")               // 这里except 就起到了我上文说的 错误提示作用
  
print("-"*50)
```

--------------------

* 下面是针对特定的类型,   **我们不用py给的异常信息,  自己定义**
* py提供的异常信息,  基本上只能在程序开发时能看见
* 面对**成熟的程序,    就应该弹出  人能看懂的错误提示**

```
try:
  # 提示用户输入一个整数
  num =int(input("请输入一个整数"))
  
  # 使用8 除以用户输出的整数  并且输出
  result = 8/num
  
  print(result)
  
except ZeroDivisionError:         // 这里except后面的内容就是  py提供的异常
  print("除0错误")                 // 这里写在except后面, 也就是想针对这种异常, 专门写的提醒信息
  
except ValueError:
  print("请输入正确的整数")
```

* 这种方式就是**针对某个特定异常, 专门去写异常信息**
* 个人感觉except 的机制,  就是**识别异常信息**



-----------------

### 捕获未知错误

* 针对特定异常信息的写了, **那针对未知的呢?**
* 开发过程中, 谁也不知道到底会发生什么 异常,    就像上面的异常
* 总不可能真的就一个个调试, 把所有异常都包括吧
* 所以, 这个**未知错误,   实际上是  程序员调试想不出来的错误**
* 捕获未知异常的代码很简单

```
#  如下

except Exception as result:            // 这个result就是个变量了, 就是那个错误的信息传入进去
                                          用result输出
  print("未知错误 %s" % result)
  
  
// 未知错误就像保底一样,   这是写异常时,  一般会写在最后的
```



-------



### 异常捕获的完整语法

* 有了异常捕获,   遇到异常会抛出
* 那如果,  **不想代码抛出异常的时候停下来, 应该怎么做呢?**
* **想要保持代码 的完整性**

```
# 如下

try:
  # 尝试执行的代码
  pass
  
except 错误类型1:
  pass
  
except 错误类型2:
  pass
  
except Exception as result:
  print("未知错误 %s" % result)
  
else:
  # 没有异常的话,  就会执行的代码   ***************
  pass
  
finally:
  #  无论是否产生异常, 都会执行的代码
  print("无论是否产生异常, 都会执行的代码")
```

* ==**else**==     **就是没有异常的话执行的代码**
* ==**finally**==     **无论是否产生异常, 都会执行的代码**





### 异常的传递性(异常最后应该写在哪里, 写在执行(主)程序里!!!)

* 首先要明确一点,  那就是产生异常后,    实际上代码里,   异常是会逐级传递的
* **异常传递最后会传给调用的那一方**
* 只有传递到主程序,   依然没有异常处理代码(就是else和finally), 程序才会终止
* ==**只需要在开发中, 在主函数里增加异常捕获就可以**==

```
# 如下所示

def demo1():
  return int(input("请输入一个整数"))
  
def demo2():
  return demo1()
  
try:
  print(demo1)
  
except 错误类型1:
  print("xxx")
  
except Exception as result:
  print("xx")
  
```

* 就和上面的代码块一样,  只要写在主程序里就行,  完全不用在内程序里写
* 因为异常是会传递的
* 况且,   在每一个执行代码里写,   会让代码变得冗余, 多余



---------------

### 主动抛出异常的案例演练

* 主动抛出异常的情况很多,   在各类程序里都会有
* 实际上, 已经体验无数次了,   就比如**密码错误, 重新输入**
* 这里最重要的还是     **Exception类**

```
def input_password():
  
  # 提示用户输入密码
  pwd=input("请输入密码")
  
  # 判断密码长度, 返回用户输入的密码
  if len(pwd) >= 8:
    return pwd
    
  # 如果 <8 就要主动抛出异常
  print("主动抛出异常")
  
  # 用Exception类创建一个对象,   并传入参数进入类, 然后由对象输出
  ex=Exception("密码长度不够")
  
  # 抛出参数  抛出
  raise ex
  
# 提示用户输入密码
print(input_password)
```

* 这里的逻辑体系要大致树立一下
* 其实也算简单

**if这个条件会判断有没有符合长度, 如果符合长度, 就会直接返回密码, 就是return的作用**

**还是对return的作用理解不深刻, return有终止的意义, 在函数里写, 意思就是以下代码不需要执行**

**而没有return呢, 就是判断不通过,  那就顺序执行代码,  调用Exception类创建对象, 然后抛出**



==return这个关键字的理解还需要大大加强==



-----

## 模块

* 模块算是**python 程序架构的核心概念**
* 就是那**一堆堆代码,  如果不是一个人写,   大家都是会各自写模块, 实现功能, 然后互相调用**
* 以 **.py**  结尾的python源代码文件都是一个**模块**
* 模块实质上就是一个**工具包**,     模块里面的 **全局变量, 函数,  类**  写出来就是给人用的
* 引用这个模块.   模块的里面的工具就可以用了

```
# 下面是 模块引用的几个用法

import 导入
import 模块1,模块2

#   加入两个模块 都定义了自己的函数, 自己类, 全局变量, 引用后应该怎么用呢

import 模块1
import 模块2

模块1.sayhello()
模块2.sayhello()
```

```
# 当然有些模块名字又臭又长, 实际在主程序里引用的时候, 用原模块名不方便
# 这里就可以给模块取别名

import 模块1 as 别名1
import 模块2 as 别名2
```

```
# 有些时候, 并不需要模块里所有的工具
# 因为有些模块会有重名方法,  如果一口气引用, 会导致重名方法误用的问题
# 而只取某些模块中,  需要的方法就行了,  重名的方法不用,  不会导致误用重名方法

# 从模块中导入一个工具
from 模块1 import 工具名

from 模块1 import 狗类
from 模块2 import say_hello
```

----

### 开发原则 和name方法的介绍应用     **************

* **有些时候, 模块导入的时候,  代码是会自动运行的**
* 可不想让他运行,  那该怎么办呢?

```
# 暂时不探究,  先搁置, 以后用到再说


```



## 包(Package)的   概念,  创建,  应用

* **包就是一个包含多个模块的特殊目录**
* package这个包很特殊,  就是**里面一定会有一个init文件**
* 这个init文件干嘛用呢,    就是一个**模块 列表**
* 别的程序引用这个包的时候,   需要**在init文件提供对外界提供的模块列表**

```
# 下面是在__init__ 文件里创建模块目录
# 很简单, 就是正常引用模块就行

import . from 模块1
import . from 模块2
```



-----

## 制作模块

* 制作模块很简单,    就是写一个set up.py文件, 然后**在终端压缩**
* 注意, pycharm本身是不能做到压缩的
* 挺简单一事,       有需要再学

---





## 文件

* 
